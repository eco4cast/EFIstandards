---
title: "Generating metadata from EFI NETCDF output"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Generating metadata from EFI NETCDF output}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, message=FALSE}
library(EML)
library(ncdf4)
library(emld)
library(lubridate)
library(tibble)
library(dplyr)
library(tidyr)
library(EFIstandards)
emld::eml_version("eml-2.2.0")
```

## Metadata from output forecast generated by FLARE
This example uses a netcdf output file produced by the Forecasting Lakes and Reservoir 
Ecosystems project (https://github.com/CareyLabVT/FLARE). The netcdf output file 
already follows the EFI recommended format for forecast output.  This vingnettes
shows how to create the EFI metadata from the output file.

We recommend reading the `logistic-metadata-example` for guidence on generating
output that meets the EFI Standard.

```{r}
file_name <- "example_output/FLARE1_FOR_H_2018_07_18_2018_07_25_F_16_20200817T112017.nc"
```

First, there is set of information that FLARE has in memory that is used to generate
the eml.

```{r} 
nstates <- 560 #Number of modeled states x number of depths
npars <- 10 #Number of parameters that fit in FLARE
n_met_members <- 21   #Number NOAA weather forecast ensemble members 
n_ds_members <- 5  #Number of weather downscaling uncertainty members
lake_name <- "Falling Creek Reservoir, Vinton, VA"
lake_latitude <- 37.307   #Degrees North
lake_longitude <- 79.837  #Degrees West
```

Second, there is a set of information requires for generating the metadata that
is FLARE already has in memory when creating the metadata.  It needs to be 
loaded here.

```{r}
abstract_text <- "This is where a longer description of the forest can be added"
forecast_title <- "FLARE"
intellectualRights <- "insert license"
model_description <- list(
  name = "General Lake Model",
  type = "process-based",
  repository = "https://github.com/AquaticEcoDynamics/GLM/releases/tag/v3.1.0"
)
me <- list(individualName = list(givenName = "Quinn", 
                                 surName = "Thomas"),
           electronicMailAddress = "rqthomas@vt.edu",
           id = "https://orcid.org/0000-0003-1282-7825")
```

## Building the metadata

Open and extract information for building the metadata file

```{r}
nc <- nc_open(file_name)
t <- ncvar_get(nc,'time')  #Saved as seconds since 1970-01-01 00:00.00 UTC
time <- as.POSIXct(t, 
                   origin = '1970-01-01 00:00.00 UTC', 
                   tz = "UTC")

#data assimilation flag
data_assimilation <- ncvar_get(nc, "data_assimilation")

#These are in the netcdf global attributed
forecast_issue_time <-ncatt_get(nc, varid = 0)$forecast_issue_time
forecast_iteration_id <- ncatt_get(nc, varid = 0)$forecast_iteration_id
forecast_project_id <- ncatt_get(nc, varid = 0)$forecast_project_id

#Number of ensemble members
nmembers <- length(ncvar_get(nc, "ensemble"))

#Vectors for building the attributes table
var_names <- names(nc$var)
attributeName <- rep(NA, length(var_names))
attributeDefinition <- rep(NA, length(var_names))
unit <- rep(NA, length(var_names))
formatString <- rep(NA, length(var_names))
numberType <- rep(NA, length(var_names))
definition <- rep(NA, length(var_names))
col_classes <- rep("numeric", length(var_names))
for(i in 1:length(var_names)){
  curr_var <- nc$var[[i]] 
  attributeName[i] <- curr_var$name #Name of variable in model
  attributeDefinition[i] <- curr_var$longname #longname in netcdf
  unit[i] <- "dimensionless" #use dimesionless in the eml and have the correct
  #units in the netcdf
  formatString[i] <- NA
  numberType[i] <- typeof(ncvar_get(nc, var_names[i]))
  if(numberType[i] == "double"){numberType[i] = "real"}
}

nc_close(nc)
```

Create the eml attributes table

```{r}
attributes <- tibble(
  attributeName = attributeName,
  attributeDefinition = attributeDefinition,
  unit = unit,
  formatString = formatString,
  numberType = numberType,
  definition = definition
)

attrList <- set_attributes(attributes, 
                           col_classes = col_classes)

```

Set metadata about the file itself (name, file type, size, MD5, etc)

```{r}
physical <- set_physical(file_name)
```

Describing the output file

```{r}
dataTable <- eml$otherEntity(
  entityName = "forecast", 
  entityDescription = "Forecast of water physics, chemistry, and biology",
  physical = physical,
  attributeList = attrList)
```

Let the eml know that the correct units can be found in the netcdf

```{r}
set_unitList(data.frame(id = 'netcdf', 
                        unitType="dimensionless",
                        "parentSI"="dimensionless", 
                        "multiplierToSI" = 1, 
                        "description"="units are defined in the netcdf file"))
```

Set the coverage for the output file

```{r}
coverage <- 
  set_coverage(begin = as_date(first(time)), 
               end = as_date(last(time)),
               geographicDescription = lake_name,
               west = lake_longitude, east = lake_longitude, 
               north = lake_latitude, south = lake_latitude)
```

Set the keywords for the output file

```{r}
keywordSet <- list(
  list(
    keywordThesaurus = "EFI controlled vocabulary",
    keyword = list("forecast",
                   "water quality",
                   "timeseries")
  ))
```

Set the abstract for the output file

```{r}
abstract <- abstract_text
```

Describing the data set 

```{r}
dataset <- eml$dataset(
  title = forecast_title,
  creator = me,
  contact = list(references=me$id),
  pubDate = as_date(as_datetime(forecast_issue_time)),
  intellectualRights = intellectualRights,
  abstract =  abstract,
  dataTable = dataTable,
  keywordSet = keywordSet,
  coverage = coverage
)
```

### EFI specific attributes

```{r}
initial_conditions <- list(
  # Possible values: no, contains, data_driven, propagates, assimilates
  uncertainty = "assimilates",
  # Number of parameters / dimensionality
  complexity = nstates,
  propagation = list(
    type = "ensemble", # ensemble vs analytic
    size = nmembers          # required if ensemble
  ),
  assimilation = list(
    type = "EnKF",
    reference = "https://www.biorxiv.org/content/10.1101/2020.01.22.915538v2.abstract",
    complexity = nstates
  )
)

parameters <- list(
  uncertainty = "assimilates",
  complexity = npars,
  propagation = list(
    type = "ensemble", # ensemble vs analytic
    size = nmembers          # required if ensemble
  ),
  assimilation = list(
    type = "EnKF",
    reference = "https://www.biorxiv.org/content/10.1101/2020.01.22.915538v2.abstract",
    complexity = npars
  )
)

process_error <- list(
  uncertainty = "propagates",
  propagation = list(
    type = "ensemble", # ensemble vs analytic
    size = nmembers          # required if ensemble
  ),
  complexity = nstates,
  covariance = TRUE,
  localization = "Distance extinction of covariance"
)

random_effects <- list(
  uncertainty = "no"
)

drivers <- list(
  uncertainty = "propagates",
  complexity = n_met_members * n_ds_members,
  propagation = list(
    type = "ensemble", # ensemble vs analytic
    size = n_met_members * n_ds_members)
)
```
Get the forecast horizon using the data assimilation flag
```{r}
forecast_horizon <- length(which(data_assimilation == 0))
```

Build the EFI additional metadata

```{r}
additionalMetadata <- eml$additionalMetadata(
  metadata = list(
    forecast = list(
      ## Basic elements
      timestep = "1 day", 
      forecast_horizon = forecast_horizon,
      forecast_issue_time = forecast_issue_time,
      forecast_iteration_id = forecast_iteration_id,
      forecast_project_id = forecast_project_id,
      model_description = model_description,
      ## UNCERTAINTY CLASSES
      initial_conditions = initial_conditions,
      parameters = parameters,
      random_effects = random_effects,
      process_error = process_error,
      drivers = drivers
    ) # forecast
  ) # metadata
) # eml$additionalMetadata
```

Build the EML

```{r}
my_eml <- eml$eml(dataset = dataset,
                  additionalMetadata = additionalMetadata,
                  packageId = forecast_project_id, 
                  system = "uuid"  ## system used to generate packageId
)
```

Check if the EML is a valid EML and whether is meets the EFI Forecasting 
Standards


```{r}
EFIstandards::forecast_validator(my_eml)
```

Write EML file

```{r}
write_eml(my_eml, paste0(file_name,"-eml.xml"))
```


```{r include=FALSE}
## Cleanup
lapply(list.files(pattern = "[.]xml"), unlink)

```